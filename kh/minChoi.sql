--쿼리문 주석

-- 현재 계정이 소유하고 있는 모든 테이블 조회

desc employees;

select * from employees;

-- 테이블에 모든 데이터 조회
SELECT * FROM DEPARTMENTS;

-- <문제> EMPLOYEES 테이블의 모든 내용 출력
SELECT * FROM EMPLOYEES;

-- 컬럼 이름을 명시해서 특정 컬럼의 데이터만 출력
-- DEPARTMENTS 테이블에서 부서번호와 부서명만 출력
SELECT DEPARTMENT_ID, DEPARTMENT_NAME FROM DEPARTMENTS;

-- <문제> 사원의 이름과 급여와 입사일자 만을 출력하는 SQL 문을 작성해보자.
-- 힌트 : 사원 정보가 저장된 테이블은 EMPLOYEES이고, 사원이름 컬럼은 FIRST_NAME, LAST_NAME과, 급여 칼럼은 SALARY, 입사일자 칼럼은 HIRE_DATE이다.
SELECT FIRST_NAME, LAST_NAME, SALARY, HIRE_DATE
FROM EMPLOYEES;

-- 컬럼 이름에 별칭 지정하기
SELECT DEPARTMENT_ID AS DepartmentNo, DEPARTMENT_NAME AS DepartmentName
FROM DEPARTMENTS;

SELECT DEPARTMENT_ID "Department No", DEPARTMENT_NAME "Department Name"
FROM DEPARTMENTS;

SELECT DEPARTMENT_ID 부서번호, DEPARTMENT_NAME 부서명
FROM DEPARTMENTS;

-- EMPLOYEES 테이블에서 여러 컬럼을 하나의 문자열로 출력하기
SELECT FIRST_NAME || '의 직급은 ' || JOB_ID || '입니다' AS 직급
FROM EMPLOYEES;

SELECT FIRST_NAME || ' ' || LAST_NAME 이름, SALARY 급여, HIRE_DATE 입사일
FROM EMPLOYEES;

-- 중복된 데이터를 한번씩만 출력하게 하는 DISTINCT
SELECT JOB_ID FROM EMPLOYEES;

-- EMPLOYEES 테이블에서 컬럼 JOB_ID를 표시하되 중복된 값은 한번만 표시하라.
SELECT DISTINCT FIRST_NAME, JOB_ID
FROM EMPLOYEES;

-- <문제>직원들이 어떤 부서에 소속되어 있는지 소속 부서번호(DEPARTMENT_ID) 출력하되 
-- 중복되지 않고 한번씩 출력하는 쿼리문을 작성하자.
SELECT DEPARTMENT_ID
FROM EMPLOYEES;

SELECT DISTINCT DEPARTMENT_ID -- DISTINCT는 중복 제거
FROM EMPLOYEES;

-- 급여를 10000 이상 받는 직원을 대상
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= 10000;

-- 급여를 3000 미만 받는 직원을 대상
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES 
WHERE SALARY < 3000;

-- <문제> EMPLOYEES 테이블에서 부서번호가 110번인 직원에 관한 모든 정보만 출력하라.
SELECT * -- 모든 정보는 *로 사용
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 110;

-- <문제> EMPLOYEES 테이블에서 급여가 5000 미만이 되는 직원의 정보 중에서 사번과 이름, 급여를 출력하라.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY < 5000;

-- 사원의 급여를 1000 인상하여 사원번호, 사원명, 급여, 인상급여, 입사일을 출력하시오.
SELECT EMPLOYEE_ID 사원번호, FIRST_NAME 사원명, SALARY 급여, SALARY+1000 인상급여, HIRE_DATE 
FROM EMPLOYEES;

-- 문자 데이터 조회
-- 이름(FIRST_NAME)이 'Lex'인 직원
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY
FROM EMPLOYEES
WHERE FIRST_NAME='Lex';

-- 이름이 John인 사람의 사원번호와 사원명과 업무ID을 출력하라.
SELECT EMPLOYEE_ID 사원번호, FIRST_NAME 사원명, JOB_ID 업무ID
FROM EMPLOYEES
WHERE FIRST_NAME='john'; -- 조건에 만족하는 데이터가 없음. 이유는 문자데이터는 대소문자를 구별하기 때문이다.

SELECT EMPLOYEE_ID 사원번호, FIRST_NAME 사원명, JOB_ID 업무ID
FROM EMPLOYEES
WHERE FIRST_NAME='John';

-- 날짜 데이터 조회
-- 2008년 이후에 입사한 직원
SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE >= '2008'; -- 에러 발생.리터럴이 형식 문자열과 일치하지 않음(ORA-01861)
                    -- 연/월/일을 갖고 있는데 연만 가져오라고 했기 때문임.
SELECT FIRST_NAME, HIRE_DATE
FROM EMPLOYEES 
WHERE HIRE_DATE >= '2008/01/01';

-- 논리연산자
-- 부서번호가 100번이고 직급이 FI_MGR인 직원
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER, DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100 AND JOB_ID = 'FI_MGR';

-- <문제>급여가 5000에서 10000이하 직원 정보 출력
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER, DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE SALARY >= 5000 AND SALARY <= 10000;

-- <문제> 사원번호가 134이거나 201이거나 107인 직원 정보 출력
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER, DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 134 OR EMPLOYEE_ID = 201 OR EMPLOYEE_ID = 107;

-- <예> 부서번호가 100번이 아닌 직원
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER, DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE NOT DEPARTMENT_ID = 100;

-- <문제> 업무ID가 FI_MGR가 아닌 직원
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE NOT JOB_ID = 'FI_MGR';

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID <> 'FI_MGR';

SELECT EMPLOYEE_ID, FIRST_NAME, EMAIL, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 1000 AND 3000;

-- <문제> 급여가 2500에서 4500까지의 범위에 속한 직원의 직원번호, 이름, 급여를 출력하라.
-- (AND 연산자와 BETWEEN AND 연산자 사용)

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY >= 2500 AND SALARY <= 4500;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY BETWEEN 2500 AND 4500;

-- <예>직원번호가 177이거나 101이거나 184인 사원
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 177 OR EMPLOYEE_ID = 101 OR EMPLOYEE_ID = 184;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE EMPLOYEE_ID IN(177, 101, 184);

-- <문제> 부서번호가 10, 20, 30 중 하나에 소속된 직원의 직원번호, 이름, 급여를 출력하라.
-- (OR 연산자와 IN 연산자 사용)
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10 OR DEPARTMENT_ID = 20 OR DEPARTMENT_ID = 30;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN(10, 20, 30);

-- <문제> 사원테이블에서 JOB_ID가 'SA_MAN', 'ST_MAN', 'PU_MAN', 'AC_MGR'인
-- 사원번호, 사원명, 직무번호를 출력하라.
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID IN('SA_MAN', 'ST_MAN', 'PU_MAN', 'AC_MGR');

-- LIKE 연산자(검색하고자 하는 값을 정확히 모를 경우 와일드카드와 함께 사용하여 원하는 내용을 검색하는 연산자)
-- % : 문자가 없거나, 하나 이상의 문자가 어떤 값이 오든 상관없다.
-- _ : 하나의 문자가 어떤 값이 오든 상관없다.
--<예> 이름 중에 k를 포함하는 사원
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE LOWER(FIRST_NAME) LIKE '%k%';
-- LOWER 소문자로 검색, 출력까지 소문자로 할거면 문자열 함수 사용해야 함.

SELECT EMPLOYEE_ID, LOWER(FIRST_NAME) -- 소문자로 출력
FROM EMPLOYEES
WHERE LOWER(FIRST_NAME) LIKE '%k%';

--<예> 이름이 k나 d로 시작,끝나는 사원
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE 'K%'; --K, Ka, Kabc..

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%k%';

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE LOWER(FIRST_NAME) LIKE '%k%';

SELECT EMPLOYEE_ID, LOWER(FIRST_NAME)  "FIRST NAME"
FROM EMPLOYEES
WHERE LOWER(FIRST_NAME) LIKE '%k';

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%k'

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_d%';

-- 핸드폰번호에서 5번째 값이 1인 레코드를 조회하고자 한다.
SELECT *
FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '____1%';

-- 사원테이블(EMPLOYEES)에서 직무ID에 3번째 _를 포함하고 4번째 자리의 값이 p인 레코드를 조회하고자 한다.
SELECT *
FROM EMPLOYEES
WHERE JOB_ID LIKE '___P%';

--ESCAPE
-- LIKE 연산으로 '%' 나 '_' 가 포함된 문자를 검색하고자 할 때 사용된다.
-- '%'나 '_' 앞에 ESCAPE로 특수문자를 지정하면 검색할 수 있다.
-- 특수문자는 아무거나 상관없이 사용 가능하다.
-- 구문 마지막에 ESCAPE에 사용할 문자열만 지정해주면 '_' 나 '%' 를 검색에 사용할 수 있게 도와준다.

-- 사원테이블(EMPLOYEES)에서 직무ID에 3번째 _를 포함하고 4번째 자리의 값이 P인 레코드를 조회하고자 한다.
SELECT * FROM EMPLOYEES
WHERE JOB_ID LIKE '__\_P%' ESCAPE '\';

SELECT * FROM EMPLOYEES
WHERE JOB_ID LIKE '__@_P%' ESCAPE '@';

-- <문제> 이름에 a를 포함하지 않은 직원의 직원번호, 이름을 출력하라.
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE LOWER(FIRST_NAME) NOT LIKE '%a%';

--- 커미션을 받지 않는 사원
SELECT EMPLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID
FROM EMPLOYEES
WHERE COMMISSION_PCT is NULL;

--- 커미션을 받는 사원
SELECT EMPLOYEE_ID, FIRST_NAME, COMMISSION_PCT, JOB_ID
FROM EMPLOYEES
WHERE COMMISSION_PCT is NOT NULL;

-- <문제> 자신의 직속상관이 없는 직원의 전체 이름과 직원번호, 업무ID를 출력하라.
SELECT * FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID is NULL;

-- <문제> 커미션을 받는 사원만 출력하되 사원번호, 이름, 급여, 수당율, 수당금액(계산식 - 급여*수당율)을 출력하라.
SELECT EMPLOYEE_ID 사원번호 , FIRST_NAME || ' ' || LAST_NAME 이름 , SALARY 급여 , COMMISSION_PCT 수당율 , SALARY*COMMISSION_PCT 수당금액
FROM EMPLOYEES
WHERE COMMISSION_PCT is NOT NULL;

-- 정렬을 위한 ORDER BY 절(오름차순 : ASC / 내림차순 : DESC )
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
ORDER BY EMPLOYEE_ID ASC;
--ORDER BY EMPLOYEE_ID;

SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
ORDER BY EMPLOYEE_ID DESC;
-- 자바 인덱스: 0 ~ 배열의크기(배열.length)-1.j(0)a(1)v(2)a(3)
-- 오라클 : 1~
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
ORDER BY 1 DESC;
-- ORDER BY 컬럼명(또는 순번) 조희의 1번이므로 EMPLOYEE_ID를 내림차순함. 2번이면 FIRST_NAME

-- NULL를 포함한 컬럼은 ASC: NULL 레코드를 제일 마지막에 / DESC: NULL 레코드를 제일 먼저 출력.
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID DESC;

-- <문제> 직원번호, 이름, 급여, 부서번호를 급여가 높은 순으로 출력하라.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY SALARY DESC, EMPLOYEE_ID DESC; --=ORDER BY 3 DESC, 1 DESC;

-- <문제> 입사일이 가장 최근인 직원 순으로 직원번호, 이름, 입사일을 출력하라.
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC; --=ORDER BY 3 DESC;

-- <문제> 부서번호가 20, 50번 부서에서 근무하는 모든 사원들의 이름(FIRST_NAME), 부서 번호, 급여를
-- 사원의 이름순(알파벳순)으로 출력하라.
SELECT FIRST_NAME, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 20 OR DEPARTMENT_ID = 50 --= WHERE DEPARTMENT_ID IN(20, 50)
ORDER BY FIRST_NAME ASC;

--사원번호, 사원명, 급여 3개의 컬럼으로 구성된 EMP01 테이블
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7, 2)

SELECT * FROM TAB;

SELECT * FROM EMP01;

DESC EMP01;

CREATE TABLE EMPLOYEE02
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM TAB;

SELECT * FROM EMPLOYEE02;

ALTER TABLE EMP01
ADD(JOB VARCHAR2(9));

-- 변경 확인
DESC EMP01;

--<문제> 이미 존재하는 EMP01 테이블에 입사일 컬럼(CREDATE) 을 날짜형으로 추가하라.
ALTER TABLE EMP01
ADD(CREDATE DATE);

-- <예> 직급을 최대 30자까지 입력할 수 있도록 크기 수정
ALTER TABLE EMP01
MODIFY(JOB VARCHAR2(30));

DESC EMP01;

--ALTER TABLE로 기존 컬럼명 변경
ALTER TABLE EMP01
RENAME COLUMN CREDATE TO REGDATE;

DESC EMP01;

--ALTER TABLE로 기존 컬럼 삭제
ALTER TABLE EMP01
DROP COLUMN JOB;

DESC EMP01;

--DROP TABLE로 테이블 구조 삭제
DROP TABLE EMP01;
-- 삭제 확인
SELECT * FROM TAB;

-- recyclebin 구조 확인
desc recyclebin;

-- 휴지통(recyclebin) 보기
SELECT * FROM recyclebin;

--실수로 지운 테이블이라 삭제를 취소하려면 다음과 같은 명령으로 다시 복구하면 된다.
--flashback table table_name to before drop;
FLASHBACK TABLE EMP01 TO BEFORE DROP;

SELECT * FROM TAB;

FLASHBACK TABLE EMP01 TO BEFORE DROP
RENAME TO EMP02;

-- 휴지통에 넣지 않고 바로 테이블을 삭제하려면 다음과 같은 명령으로 휴지통에 넣지 않고 삭제를 할 수 있다.
drop table emp01 purge;

RENAME EMPLOYEE02 TO EMPLOYEES01;

SELECT * FROM TAB;

SELECT * FROM EMPLOYEES01;
TRUNCATE TABLE EMPLOYEES01;
SELECT * FROM EMPLOYEES01;

SELECT * FROM TAB;

CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7, 2)
);

SELECT * FROM TAB;

SELECT * FROM EMP01;

DESC EMP01;

DELETE FROM EMP01;

DROP TABLE EMP01;

SELECT * FROM TAB;

-- 고객 테이블 생성
CREATE TABLE TB_CUSTOMER(
    CUSTOMER_CD     CHAR (7)        NOT NULL PRIMARY KEY,       -- 고객코드(컬럼 레벨 형식)
    CUSTOMER_NM     VARCHAR2 (15)   NOT NULL,                   -- 고객명 (컬럼 레벨 형식)
    MW_FLG          CHAR (1)        NOT NULL, -- M(남성)W(여성)  -- 성별구분(컬럼 레벨 형식)
    BIRTH_DAY       CHAR (8)        NOT NULL,                   -- 생일(컬럼 레벨 형식)
    PHONE_NUMBER    VARCHAR2 (16),                              -- 전화번호
    EMAIL           VARCHAR2 (50),                              -- EMAIL
    TOTAL_POINT     NUMBER (10),                                -- 누적포인트
    REG_DTTM        CHAR (14)                                   -- 등록일
);

DESC TB_CUSTOMER; -- DESC는 구조 확인 명령문

SELECT * FROM TB_CUSTOMER;

INSERT INTO TB_CUSTOMER (CUSTOMER_CD, CUSTOMER_NM, MW_FLG, BIRTH_DAY, PHONE_NUMBER, EMAIL, TOTAL_POINT, REG_DTTM)
VALUES(2017042, '강원진', 'M', '19810603', '010-8202-8790', 'wjgang@navi.com', 280300, '20170123132432');
INSERT INTO TB_CUSTOMER (CUSTOMER_CD, CUSTOMER_NM, MW_FLG, BIRTH_DAY, PHONE_NUMBER, EMAIL, TOTAL_POINT, REG_DTTM)
VALUES(2017053, '나경숙', 'W', '19891225', '010-4509-0043', 'ksna@boram.co.kr', 4500, '20170210180930');
INSERT INTO TB_CUSTOMER (CUSTOMER_CD, CUSTOMER_NM, MW_FLG, BIRTH_DAY, PHONE_NUMBER, EMAIL, TOTAL_POINT, REG_DTTM)
VALUES(2017103, '박승대', 'M', '19711430', '', 'sdpark@haso.com', 23450, '20170508203450');

SELECT * FROM TB_CUSTOMER;

--임시테이블
INSERT ALL
INTO TB_CUSTOMER (CUSTOMER_CD, CUSTOMER_NM, MW_FLG, BIRTH_DAY, PHONE_NUMBER, EMAIL, TOTAL_POINT, REG_DTTM)
VALUES(2017042, '강원진', 'M', '19810603', '010-8202-8790', 'wjgang@navi.com', 280300, '20170123132432');
INTO TB_CUSTOMER
VALUES(2017053, '나경숙', 'W', '19891225', '010-4509-0043', 'ksna@boram.co.kr', 4500, '20170210180930');
INTO TB_CUSTOMER
VALUES(2017103, '박승대', 'M', '19711430', '', 'sdpark@haso.com', 23450, '20170508203450');
SELECT * FROM DUAL;


DESC DUAL;

SELECT 100+4 FROM DUAL;
SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR (SYSDATE, 'YYYY-MM-DD HH24:MI:SS') AS NOWDATE FROM DUAL;
--SYSDATE는 오늘 날짜와 시간을 가지고 있는 날짜 함수, 문자변환함수 TO_CHAR와 같이 사용

SELECT * FROM TB_CUSTOMER;
--DELETE FROM TB_CUSTOMER;
-------------------------------------------------------
-- 데이터 입력, 수정, 삭제
CREATE TABLE DEPT(
    DEPTNO NUMBER (2),
    DNAME VARCHAR2 (14),
    LOC VARCHAR2 (13)
);

DESC DEPT;

SELECT * FROM TAB;

--DEPTNO에 10번 부서, DNAME에는 'ACCOUNTING'을, LOC에는 'NEW YORK'을 추가하자.
INSERT INTO DEPT(DEPTNO, DNAME, LOC)
VALUES(10, 'ACCOUNTING', 'NEW YORK');

SELECT * FROM DEPT;
--커밋(F11) , 롤백(F12)  완료 및 취소 (이미 커밋하면 롤백하지 못 함)

--SQL 오류: ORA-00947: 값의 수가 충분하지 않습니다
INSERT INTO DEPT(DEPTNO, DNAME, LOC)
VALUES (10, 'ACCOUNTING');

INSERT INTO DEPT
VALUES(20, 'RESEARCH', 'DALLAS');

SELECT * FROM DEPT;

INSERT INTO DEPT(DEPTNO, DNAME, LOC)
VALUES(10, 'ACCOUNTING', 'NEW YORK');

SELECT * FROM DEPT;

INSERT INTO DEPT
VALUES(20, 'RESEARCH', 'DALLAS');

SELECT * FROM DEPT;

DELETE FROM DEPT; 

INSERT INTO DEPT(DEPTNO, DNAME, LOC)
VALUES(10, 'ACCOUNTING', 'NEW YORK');

INSERT INTO DEPT
VALUES(20, 'RESEARCH', 'DALLAS');

SELECT * FROM DEPT;

--NOT NULL로 변경--
ALTER TABLE DEPT
MODIFY(DEPTNO NUMBER(2) NOT NULL);

ALTER TABLE DEPT
MODIFY(DNAME VARCHAR2(14) NOT NULL);

SELECT * FROM DEPT;

INSERT INTO DEPT(DEPTNO, DNAME)-- 컬럼명을 2개 입력해서 값도 2개 입력.
VALUES (30, 'SALES');
------------------

-- SQL 오류: ORA-00947: 값의 수가 충분하지 않습니다
INSERT INTO DEPT --컬럼명을 입력하지 않아서 값이 3개 필요하기에 오류 발생.
VALUES (40, 'OPERATIONS');

INSERT INTO DEPT
VALUES (40, 'OPERATIONS', NULL);

SELECT * FROM DEPT;

--SQL 오류: ORA-01400: NULL을 ("HR"."DEPT"."DNAME") 안에 삽입할 수 없습니다
INSERT INTO DEPT
VALUES (50, '', 'CHICAGO');

SELECT * FROM DEPT;

DELETE FROM DEPT;

ALTER TABLE DEPT MODIFY(DEPTNO NUMBER(4), DNAME VARCHAR2(30));

INSERT INTO DEPT
SELECT DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS;

SELECT * FROM DEPT;
------------------------------
--INSERT ALL
--두 개 이상의 테이블에INSERT ALL을 이용하여 한 번에 삽입 가능
--단, 각 서브쿼리의 조건절이 같아야 함

CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, HIRE_DATE
FROM EMPLOYEES
WHERE 1 = 0;

CREATE TABLE EMP_MANAGER
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES
WHERE 1 = 0;

SELECT * FROM EPM01;

--EMP01 테이블에 EMPLOYEES 테이블에서 부서코드가 30인 직원의 사번, 이름, 소속부서, 입사일을 삽입하고
--EMP_MANAGER테이블에 EMPLOYEES 테이블의 부서코드가 30인 직원의 사번, 이름, 관리자 사번을 조회하여 삽입

INSERT ALL

INTO EMP01
VALUES(EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, HIRE_DATE)

INTO EMP_MANAGER
VALUES(EMPLOYEE_ID, FIRST_NAME, MANAGER_ID)

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID, HIRE_DATE, MANAGER_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;

SELECT * FROM EMP01;
SELECT * FROM EMP_MANAGER;

-- EMPLOYEES 테이블의 구조를 복사하여 사번, 이름, 입사일, 급여를 저장할 수 있는 테이블 EMP_OLD와 EMP_NEW 생성
CREATE TABLE EMP_OLD
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
WHERE 1 = 0;

CREATE TABLE EMP_NEW
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES
WHERE 1 = 0;

-- EMPLOYEES 테이블의 입사일 기준으로
-- 2006년 1월 1일 전에 입사한 사원의 사번, 이름, 입사일, 급여를 조회해서 EMP_OLD 테이블에 삽입하고
--               후에 입사한 사원의 정보는 EMP_NEW 테이블에 삽입하고자 한다.
INSERT ALL
WHEN HIRE_DATE < '2006/01/01' THEN -- 오라클에서는 WHEN ~ THEN이 조건식임
    INTO EMP_OLD
    VALUES(EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY)
WHEN HIRE_DATE >= '2006/01/01' THEN
    INTO EMP_NEW
    VALUES(EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY)

SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES;

SELECT * FROM EMP_OLD; 
SELECT * FROM EMP_NEW;

CREATE TABLE EMP
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP;

UPDATE EMP
SET DEPARTMENT_ID = 30;

SELECT * FROM EMP;

UPDATE EMP
SET SALARY = SALARY * 1.1;

SELECT * FROM EMP;

UPDATE EMP SET HIRE_DATE = SYSDATE;

SELECT * FROM EMP;

SELECT * FROM EMP01;

DROP TABLE EMP;
CREATE TABLE EMP 
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP;

UPDATE EMP
SET DEPARTMENT_ID = 30
WHERE DEPARTMENT_ID = 10;

SELECT * FROM EMP;

UPDATE EMP
SET SALARY = SALARY * 1.1
WHERE SALARY >= 3000;

SELECT * FROM EMP;

-- 2007년에 입사한 사원을 오늘날짜로 변경하는 작업을 진행해 봅시다.
SELECT * FROM EMP WHERE HIRE_DATE BETWEEN '07/01/01' AND '07/12/31';
SELECT * FROM EMP WHERE SUBSTR (HIRE_DATE, 1, 2) = '07';

UPDATE EMP
SET HIRE_DATE = SYSDATE --SYSDATE(현재날짜 및 시간)로 수정
WHERE SUBSTR(HIRE_DATE,1,2) = '07'; 
--SUBSTR 문자 다룰 때 쓰는 함수, 1 첫번 째 자리부터 2 두개를 가지고 와라. (입사 "년도")
-- 년/ 월 / 일을 가지는 함수이므로 "2007" 이렇게 하면 오류남. 따라서 07을 가져오기 위해 사용. (between 써도 됨)
--이건 함수써서 값을 자른것이기 때문에, 범위값으로 변경하는게 더 좋음(속도 향상 등). 
UPDATE EMP
SET HIRE_DATE + SYSDATE
WHERE HIRE_DATE BETWEEN '07/01/01' AND '07/12/31';

SELECT TO_CHAR(HIRE_DATE, 'YYYY-MM-DD') AS HIRE_DATE FROM EMP;

SELECT * FROM EMP WHERE SUBSTR (HIRE_DATE, 1, 2) = '22';

SELECT * FROM EMP;

SELECT * FROM EMP WHERE FIRST_NAME = 'Susan';

UPDATE EMP
SET DEPARTMENT_ID=20, JOB_ID='FI_MGR'
WHERE FIRST_NAME = 'Susan';

SELECT * FROM EMP;

SELECT * FROM EMP WHERE LAST_NAME = 'Russell';

UPDATE EMP
SET SALARY = 17000, COMMISSION_PCT = 0.45
WHERE LAST_NAME = 'Russell';

SELECT * FROM EMP WHERE LAST_NAME = 'Russell';

--<문제> TB_CUSTOMER 테이블에서 박승대 고객의 생년월일을 
--19711230인데 잘못입력하여 19711430을 입력하였다. 생년월일을 수정해주세요.

SELECT * FROM TB_CUSTOMER WHERE BIRTH_DAY = 19711430;

UPDATE TB_CUSTOMER
SET BIRTH_DAY = 19711230
WHERE BIRTH_DAY = 19711430;

SELECT * FROM TB_CUSTOMER WHERE BIRTH_DAY = 19711230;

-- UPDATE TB_CUSTOMER SET BIRTH_DAY = '19771230'
-- WHERE CUSTOMER_CD = 2017103;
-- SELECT * FROM TB_CUSTOMER WHERE BIRTH_DAY = 19711230;

DELETE FROM DEPT;

SELECT * FROM DEPT;

DELETE FROM DEPT WHERE DEPTNO = 30;

SELECT * FROM DEPT;

--실습을 위해 테이블을 만들어보자.
CREATE TABLE TB_ADD_CUSTOMER (
    CUSTOMER_CD     CHAR(7)         NOT NULL PRIMARY KEY,   --고객코드
    CUSTOMER_NM     VARCHAR2(10)    NOT NULL,               --고객명
    MW_FLG          CHAR(1)         NOT NULL,               --성별 구분
    BIRTH_DAY       CHAR(8)         NOT NULL,               --생일
    PHONE_NUMBER    VARCHAR2(16)                            --전화번호
);

INSERT INTO TB_ADD_CUSTOMER(customer_cd, customer_nm, mw_flg, birth_day, phone_number)
VALUES('2017108', '박승대', 'M', '19711230', '010-2580-9919');

INSERT INTO TB_ADD_CUSTOMER(customer_cd, customer_nm, mw_flg, birth_day, phone_number)
VALUES('2019302', '전미래', 'W', '19740812', '010-8864-0232');

SELECT * FROM TB_ADD_CUSTOMER;

--TB_ADD_CUSTOMER 테이블의 내용을 TB_CUSTOMER 테이블과 비교하여 데이터가 있을 경우 업데이트하고
--데이터가 없을 경우 입력되도록 쿼리문을 작성한다.

MERGE INTO TB_CUSTOMER CU
    USING TB_ADD_CUSTOMER NC
    ON  (CU.CUSTOMER_CD = NC.CUSTOMER_CD)
    WHEN MATCHED THEN
        UPDATE SET CU.CUSTOMER_NM = NC.CUSTOMER_NM,
                  CU.MW_FLG = NC.MW_FLG,
                  CU.BIRTH_DAY = NC.BIRTH_DAY,
                  CU.PHONE_NUMBER = NC.PHONE_NUMBER
    WHEN NOT MATCHED THEN
        INSERT (CU.CUSTOMER_CD, CU.CUSTOMER_NM, CU.MW_FLG, CU.BIRTH_DAY,
                CU.PHONE_NUMBER, CU.EMAIL, CU.TOTAL_POINT, CU.REG_DTTM)
        VALUES (NC.CUSTOMER_CD, NC.CUSTOMER_NM, NC.MW_FLG, NC.BIRTH_DAY,
                NC.PHONE_NUMBER, '', 0, TO_CHAR(SYSDATE, 'YYYYMMDDHHMISS'));
                
SELECT * FROM TB_CUSTOMER;
------------------------------------------------------
-- 카페 테이블 3개 만들기 예제
CREATE TABLE MEMBER(
    ID              NUMBER (20)     NOT NULL PRIMARY KEY,   -- 회원ID
    NAME            VARCHAR2 (20)   NOT NULL,               -- 이름
    REGNO           CHAR (8)        NOT NULL,               -- 생년월일
    HP              VARCHAR2 (13)   NOT NULL,               -- 핸드폰번호
    ADDRESS         VARCHAR2 (100)  NOT NULL                -- 주소
);

DESC MEMBER;

SELECT * FROM MEMBER;
----------------------------------------------------
CREATE TABLE BOOK(
    CODE            NUMBER (4)      NOT NULL PRIMARY KEY,   -- 제품코드
    TITLE           VARCHAR2 (100)  NOT NULL,               -- 도서명
    COUNT           NUMBER (6)      NOT NULL,               -- 수량
    PRICE           NUMBER (10)     NOT NULL,               -- 정가
    PUBLISH         VARCHAR2 (50)   NOT NULL                -- 출판사
);

DESC BOOK;

SELECT * FROM BOOK;
----------------------------------------------------
CREATE TABLE BOOK_ORDER(
    NO              VARCHAR2 (10)   NOT NULL PRIMARY KEY,   -- 주문번호
    ID              VARCHAR2 (20)   NOT NULL,               -- 회원ID
    CODE            NUMBER (4)      NOT NULL,               -- 제품코드
    COUNT           NUMBER (6)      NOT NULL,               -- 주문권수
    OR_DATE         DATE ()         NOT NULL                -- 주문일자
);

DESC BOOK_ORDER;

SELECT * FROM BOOK_ORDER;
--------------------------------------------------

DROP TABLE EMP01 PURGE; -- 복원 필요없이 삭제

CREATE TABLE EMP01 (
    EMPNO NUMBER (4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2 (9),
    DEPTNO NUMBER (4)
);

INSERT INTO EMP01
VALUES (NULL, NULL, 'SALESMAN', 30);

SELECT * FROM EMP01;

CREATE TABLE EMP02 (
    EMPNO NUMBER(4) UNIQUE,--NULL까지 제한하려면 EMPNO NUMBER(4) NOT NULL UNIQUE
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4)
);

INSERT INTO EMP02(EMPNO, ENAME, JOB, DEPTNO)
VALUES (7499, 'ALLEN', 'SALESMAN', 30);

INSERT INTO EMP02(EMPNO, ENAME, JOB, DEPTNO)
VALUES (NULL, 'JONES', 'MANAGER', 20); 
--NULL은 값(VALUE)에서 제외되므로 유일한 조건인지를 체크하는 값에서 제외된다. 정상실행
INSERT INTO EMP02(EMPNO, ENAME, JOB, DEPTNO)
VALUES (NULL, 'JONES', 'SALESMAN', 10);

SELECT TABLE_NAME FROM USER_TABLES
ORDER BY TABLE_NAME DESC;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP02';

SELECT OWNER, CONSTRAINT_NAME, TABLE_NAME, COLUMN_NAME FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'EMP02';

DROP TABLE EMP03;

CREATE TABLE EMP03 (
    EMPNO NUMBER (4)    PRIMARY KEY,--primary key는 무조건 not null이며 테이블 당 1개만 존재.
    ENAME VARCHAR2(10)  NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER (4)
);

INSERT INTO EMP03
VALUES (7499, 'ALLEN', 'SALESMAN', 30);

INSERT INTO EMP03
VALUES (NULL, 'JONES', 'MANAGER', 20);

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP03';

CREATE TABLE DEPT01 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14) NOT NULL,
    LOC VARCHAR2 (13)
);

Insert into DEPT01 (DEPTNO, DNAME, LOC) values (10, 'ACCOUNTING', 'NEW YORK');
Insert into DEPT01 (DEPTNO, DNAME, LOC) values (20, 'RESEARCH', 'DALLAS');
Insert into DEPT01 (DEPTNO, DNAME, LOC) values (30, 'SALES', 'CHICAGO');
Insert into DEPT01 (DEPTNO, DNAME, LOC) values (40, 'OPERATIONS', 'BOSTON');

SELECT * FROM DEPT01;

INSERT INTO EMP03
VALUES (7566, 'JONES', 'MANAGER', 50);

SELECT * FROM EMP03;

--사원테이블(참조하는 자식테이블)
CREATE TABLE EMP04 (
    EMPNO NUMBER (4) PRIMARY KEY,                   --사원번호
    ENAME VARCHAR2 (10) NOT NULL,                   --사원명
    JOB VARCHAR2 (9),                               --직무
    DEPTNO NUMBER (2) REFERENCES DEPT01(DEPTNO)     --부서번호
);

INSERT INTO EMP04
VALUES (7499, 'ALLEN', 'SALESMAN', 30);

--ORA-02291: 무결성 제약조건(HR.SYS_C008391)이 위배되었습니다- 부모 키가 없습니다
INSERT INTO EMP04
VALUES (7566, 'JONES', 'MANAGER', 50);

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP04';

CREATE TABLE EMP05 (
    EMPNO NUMBER (4) PRIMARY KEY,
    ENAME VARCHAR2 (10) NOT NULL,
    GENDER VARCHAR2 (1) CHECK (GENDER IN('M', 'F')),
    REGDATE DATE DEFAULT SYSDATE
);

--* NOT NULL, CHECK, DEFAULT 변경은
-- ALTER TABLE 테이블 MODIFY(컬럼명 자료형 제약조건)으로

INSERT INTO EMP05 (EMPNO, ENAME, GENDER)
VALUES (7566, 'JONES', 'M');

INSERT INTO EMP05
VALUES (7566, 'JONES', 'M', SYSDATE);

SELECT * FROM EMP05;

INSERT INTO EMP05 (EMPNO, ENAME, GENDER)
VALUES (7566, 'JONES', 'A');

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP05';